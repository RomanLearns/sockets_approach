import React, { useState, useEffect, useRef } from 'react';
import NameInput from './NameInput';
import Lobby from './Lobby';
import GameScreen from './GameScreen';
import { WebSocketProvider, useWebSocket } from './WebSocketContext'; // We will create this context
import * as config from './config';
import './App.css';

function App() {
  const [userName, setUserName] = useState('');
  const [userUuid, setUserUuid] = useState(''); // UUID generated by NameInput
  const [currentScreen, setCurrentScreen] = useState('nameInput'); // 'nameInput', 'lobby', 'game'
  const [gameData, setGameData] = useState(null); // { game_id, player_piece, initial_state / current_state }
  const [availableGames, setAvailableGames] = useState([]);
  const [serverError, setServerError] = useState(null); // General server errors

  // WebSocket handling is moved into App to manage global state updates
  // The WebSocketContext will provide the instance and send function

  // Handler for entering the lobby from NameInput
  const handleEnterLobby = (name, uuid) => {
    console.log('App: Received name and UUID:', { name, uuid });
    setUserName(name);
    setUserUuid(uuid);
    setCurrentScreen('lobby');
    // Connection to WebSocket is established via WebSocketProvider wrapping App
  };

  // Handler for transitioning to GameScreen
  const handleEnterGame = (gameInfo) => {
    console.log('App: Entering game screen with:', gameInfo);
    setGameData(gameInfo);
    setCurrentScreen('game');
  };

  // Handler for transitioning back to Lobby from GameScreen
  const handleBackToLobby = () => {
    console.log('App: Returning to lobby.');
    setGameData(null);
    setCurrentScreen('lobby');
    // Server should send available games list upon returning to lobby or periodically
  };

  // This useEffect will run only once after initial render to connect WebSocket
  // The WebSocketProvider component handles the actual connection lifecycle
  // and passes down the websocket instance and handlers via context.
  // App consumes the context and sets up the central message handler.
  const { websocket, isConnected, sendMessage, setError: setContextError } = useWebSocket();


  // Central message handler for WebSocket
  useEffect(() => {
    if (!websocket) return; // Don't set handler if websocket is not ready

    websocket.onmessage = (event) => {
      try {
        const message = JSON.parse(event.data);
        console.log('App: Received message:', message.action, message); // Log action

        switch (message.action) {
          case 'registered':
            console.log('App: Registration confirmed by server.');
            // Server should send available_games_update next
            // No state change needed here, indicates connection is valid
            break;

          case 'available_games_update':
            console.log('App: Updating available games list.');
            setAvailableGames(message.games || []);
            // Ensure we are on the lobby screen if receiving this
            if (currentScreen !== 'game') {
                 setCurrentScreen('lobby');
            }
            break;

          case 'game_created':
          case 'game_start': // Both actions indicate a game is beginning/resuming for the player
          case 'rejoin_game':
            console.log(`App: Received game start/rejoin action: ${message.action}. Transitioning to game.`);
             // Determine player piece from game_state if not provided explicitly
             const piece = message.player_piece ||
                           (message.game_state?.players?.X?.uuid === userUuid ? 'X' : 'O');
            handleEnterGame({
              game_id: message.game_id,
              player_piece: piece,
              initial_state: message.game_state, // This will be the state when entering/rejoining
            });
            setServerError(null); // Clear any previous error on successful game entry
            break;

          case 'game_update':
            console.log('App: Received game update.');
            if (gameData && message.game_id === gameData.game_id) {
              // Update the game state with the new board and turn
              setGameData(prev => ({
                  ...prev,
                  initial_state: { // Update the state structure stored
                      ...prev.initial_state,
                      board: message.board,
                      turn: message.next_turn_piece,
                      status: 'active', // Ensure status is active during updates
                      winner: null,
                  }
              }));
            }
            break;

          case 'game_over':
            console.log('App: Received game over.');
             if (gameData && message.game_id === gameData.game_id) {
                 // Update the game state with the final board, winner, and tie status
                 setGameData(prev => ({
                     ...prev,
                     initial_state: { // Update the state structure stored
                         ...prev.initial_state,
                         board: message.board,
                         turn: null, // Game over, no turn
                         status: 'finished',
                         winner: message.winner_piece,
                         is_tie: message.is_tie,
                     }
                 }));
                 // Stay on game screen to show results, Back button returns to lobby
             }
            break;

          case 'move_error':
            console.log('App: Received move error:', message.message);
            // Display the error to the user, perhaps briefly or in a dedicated area
            setServerError(`Move Error: ${message.message}`);
            // Optionally update board to server's state if provided
             if (gameData && message.game_id === gameData.game_id && message.board) {
                 setGameData(prev => ({
                     ...prev,
                     initial_state: { ...prev.initial_state, board: message.board }
                 }));
             }
            break;

         case 'game_error':
            console.log('App: Received game error:', message.message);
            setServerError(`Game Error: ${message.message}`);
             // If an error occurs related to joining/creating, go back to lobby state
             if (currentScreen !== 'lobby') {
                 handleBackToLobby(); // Returns to lobby, clears gameData
             }
             // Server should send updated available_games_update after game_error if relevant
            break;

         case 'opponent_disconnected':
             console.log('App: Received opponent disconnected:', message.message);
             setServerError(`Opponent disconnected: ${message.message}. Returning to lobby.`);
             // Force return to lobby state after a delay
             setTimeout(() => {
                  handleBackToLobby(); // Returns to lobby, clears gameData
                  setServerError(null); // Clear the disconnection message
             }, 3000);

             break;

          case 'error':
            console.error('App: Received generic server error:', message.message);
            setServerError(`Server Error: ${message.message}`);
            break;

          default:
            console.warn('App: Received unknown action:', message.action, message);
        }

      } catch (e) {
        console.error('App: Error processing message:', e, event.data);
        setServerError("Error processing server message.");
      }
    };

    // Cleanup function for the effect
    return () => {
       // Handlers attached by websockets library often don't need explicit removal
       // if the websocket instance itself is managed (e.g., closed on unmount).
       // WebSocketContext takes care of closing the connection.
       console.log('App: Cleaning up WebSocket message handler effect.');
    };

  }, [websocket, userUuid, gameData, currentScreen]); // Re-run if websocket, uuid, gameData, or screen changes


  // Render the appropriate screen based on currentScreen state
  let content;
  if (currentScreen === 'nameInput') {
    content = <NameInput onEnterLobby={handleEnterLobby} />;
  } else if (currentScreen === 'lobby') {
    content = <Lobby
                userName={userName}
                userUuid={userUuid}
                availableGames={availableGames} // Pass state from App
                onEnterGame={handleEnterGame} // Pass handler to trigger game entry
                serverError={serverError} // Pass error state
                setServerError={setServerError} // Allow children to clear errors maybe
              />;
  } else if (currentScreen === 'game') {
    content = <GameScreen
                gameState={gameData} // Pass current game state
                userUuid={userUuid}
                onBackToLobby={handleBackToLobby} // Pass handler to return to lobby
                serverError={serverError} // Pass error state
                setServerError={setServerError} // Allow children to clear errors maybe
              />;
  }

  return (
      // WebSocketProvider wraps the entire app or relevant parts
      // The provider manages the websocket connection state
       <div className="App">
          <h1>Tic Tac Toe</h1>
           {/* Display connection status (optional) */}
           {/* {!isConnected && currentScreen !== 'nameInput' && (
               <div className="info-message">Connecting...</div>
           )} */}
           {content}
       </div>
  );
}

// Wrap App with the WebSocketProvider
export default function AppWithWebSocket() {
    // UUID generation can stay here or in NameInput
    // Let's generate it once here for the WebSocket connection
     const initialUuid = `client-${Math.random().toString(36).substr(2, 9)}`;
     const [userUuidForWs, setUserUuidForWs] = useState(initialUuid);

     // Pass the UUID down to App to be used in messages
     // App will manage the userUuid state obtained *after* NameInput submission
     // The UUID used for the WebSocket connection itself can be generated immediately
     // App needs to *know* the UUID it's using for the connection to include in messages.
     // Let's generate the client UUID within App after name submission.
     // The WebSocketProvider itself doesn't strictly need the UUID for connecting,
     // the server just needs it in the first 'register' message.

     // Revised: Generate UUID in App after name submission and pass it down.
     // WebSocketProvider doesn't need it upfront. App passes userUuid prop to it maybe?
     // No, WebSocketProvider should be simple. App's onmessage handler will get the UUID
     // from its own state and include it in messages it *sends*.
     // WebSocketProvider just needs the server URL.

     // Let's revert UUID generation to NameInput and pass it up to App.
     // App then manages userUuid state and uses it for sending messages.
     // WebSocketProvider doesn't need userUuid initially.

    return (
        <WebSocketProvider serverUrl={config.SERVER_URL}>
            <App /> {/* App will manage userUuid internally after NameInput */}
        </WebSocketProvider>
    );
}
